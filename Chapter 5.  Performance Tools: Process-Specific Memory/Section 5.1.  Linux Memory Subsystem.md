### 5.1\. Linux Memory Subsystem

When diagnosing memory <a name="iddle1112"></a><a name="iddle1113"></a><a name="iddle1114"></a>performance problems, it may become necessary to observe how an application performs at various levels within the memory subsystem. At the top level, the operating system decides how the swap and physical memory are being used. It decides what pieces of an application's address space will be in physical memory, which is called the resident set. Other memory used by the application but not part of the resident set will be swapped to disk. The application decides how much memory it will request from the operating system, and this is called the virtual set. The application can allocate this explicitly by calling <tt>malloc</tt> or implicitly by using a large amount of stack or using a large number of libraries. The application can also allocate shared memory that can be used by itself and other applications. The <tt>ps</tt> performance tool is useful for tracking the virtual and resident set size. The <tt>memprof</tt> performance tool is useful for tracking which code in an application is allocating memory. The <tt>ipcs</tt> tool is useful for tracking shared memory usage.

When an <a name="iddle1115"></a><a name="iddle1116"></a><a name="iddle1117"></a><a name="iddle1118"></a><a name="iddle1119"></a>application is using physical memory, it begins to interact with the CPU's cache subsystem. Modern CPUs have multiple levels of cache. The fastest cache is closest to the CPU (also called L1 or Level 1 cache) and is the smallest in size. Suppose, for instance, that the CPU has only two levels of cache: L1 and L2\. When the CPU requests a piece of memory, the processor checks to see whether it is already in the L1 cache. If it is, the CPU uses it. If it was not in the L1 cache, the processor generates a L1 cache miss. It then checks in the L2 cache; if the data is in the L2 cache, it is used. If the data is not in the L2 cache, an L2 cache miss occurs, and the processor must go to physical memory to retrieve the information. Ultimately, it would be best if the processor never goes to physical memory (because it finds the data in the L1 or even L2 cache). Smart cache use—rearranging an application's data structures and reducing code size, for example—may make it possible to reduce the number of caches misses and increase performance. <tt>cachegrind</tt> <a name="iddle1120"></a><a name="iddle1121"></a><a name="iddle1122"></a><a name="iddle1123"></a><a name="iddle1124"></a><a name="iddle1125"></a><a name="iddle1126"></a><a name="iddle1127"></a><a name="iddle1128"></a><a name="iddle1129"></a>and <tt>oprofile</tt> are great tools to find information about how an application is using the cache and about which functions and data structures are causing cache misses.