### 6.1\. Introduction to Disk I/O

Before diving into <a name="iddle1434"></a>performance tools, it is necessary to understand how the Linux disk I/O system is structured. Most modern Linux systems have one or more disk drives. If they are IDE drives, they are usually named <tt>hda</tt>, <tt>hdb</tt>, <tt>hdc</tt>, and so on; whereas SCSI drives are usually named <tt>sda</tt>, <tt>sdb</tt>, <tt>sdc</tt>, and so on. A disk is typically split into multiple partitions, where the name of the partition's device is created by adding the partition number to the end of the base device name. For example, the second partition on the first IDE hard drive in the system is usually labeled <tt>/dev/hda2</tt>. Each individual partition usually contains either a file system or a swap partition. These partitions are mounted into the Linux root file system, as specified in <tt>/etc/fstab</tt>. These mounted file systems contain the files that applications read to and write from.

When an application does a read or write, the Linux kernel may have a copy of the file stored into its cache or buffers and returns the requested information without ever accessing the disk. If the Linux kernel does not have a copy of the data stored in memory, however, it adds a request to the disk's I/O queue. If the Linux kernel notices that multiple requests are asking for contiguous locations on the disk, it merges them into a single big request. This merging increases overall disk performance by eliminating the seek time for the second request. When the request has been placed in the disk queue, if the disk is not currently busy, it starts to service the I/O request. If the disk is busy, the request waits in the queue until the drive is available, and then it is serviced.